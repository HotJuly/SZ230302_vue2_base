# Vue2组件通讯方式总结

## 1.props(频率高)

```javascript
适用场景:父子之间
	它可以实现父传子,也可以实现子传父
	所谓的父子关系,就说明当前两个组件之间,一定有结构嵌套
		在一个组件的template中,一定能看到另一个组件的组件标签
		
父传子:
	1.父组件在子组件的标签上,添加标签属性,并将需要传递的数据写在属性值中
	2.子组件在自己的配置对象上,书写props规则,用于声明需要接收的标签属性以及对应的值
	
子传父:
	其实就是数据在子组件,父组件想要接收
	1.父组件还是通过子组件的标签,给子组件添加标签属性,属性值是一个接收数据的函数
	2.子组件在自己的配置对象中,添加props规则,接收父组件传下来的函数
	3.子组件调用接收到的函数,并向函数内部传入数据
		最终被函数的形参接收,父组件就可以使用该数据
		
	注意点:
		1.请问父组件接收数据的函数,一定要写在methods中吗?
		回答:必须写在methods中
			原因:因为写在methods中的函数,他们的this都会被强行修改为当前组件的实例对象
				如果不写在methods中,那么该函数的this就会随着使用者而发生变化
				
				原理:其实只要放在methods中的函数,Vue底层都会对它们使用bind来强行修改this指向
					顺便说一下,bind函数修改过的this指向,无法二次修改
		
 总结:
	父传子,父组件传的是真正的数据
	子传父,父组件传的是接收数据的函数
```

## 2.provide/inject(频率低)

```
适用场景:祖孙之间

	基础流程:
		1.在祖先组件的配置对象中,添加provide配置属性,属性值可以是对象||函数
			将需要暴露的数据写在内部
		2.在后代组件的配置对象中,添加inject配置属性,属性值是Array<string>
			内部的字符串代表着需要接收的数据名称,与流程1中的属性名对应
			
	注意:
		1.如果provide暴露的数据,想要是data中的某个数据,那么就只能使用函数写法
			原因:provide函数,会在data函数执行之后才会执行,此时当前组件的this就已经创建了
	
		2.该方案可以实现祖先向后代组件传数据,也可以实现后代组件向祖先组件传递数据
			如果想要实现后代组件向祖先组件传递数据
				必须满足三个条件:
					1.必须在祖先组件的data中声明一个对象
					2.必须通过provide函数暴露这个对象
					3.后代组件只能修改对象中的属性
	
```

## 3.自定义事件(频率高)

```
适用场景:父子之间(单向,子向父)

问题:什么是事件?
回答:事件指的是在程序运行过程中,发生的事情或者发生操作
	例如click事件
		用户可能会点击某个按钮,那么就会触发这个按钮的click事件
		
问题:事件组成三要素?
	1.事件源
	2.事件名(事件类型)
	3.事件处理器(又称为事件监听,事件回调函数)
	
问题:请问Vue中事件分为几类?
回答:
	1.原生事件
	2.自定义事件
	
问题:请问什么是原生事件?什么是自定义事件?
回答:
	原生事件
		原生事件是由W3C推出的一套事件机制
		一个标签具有哪些原生事件,都是W3C机构指定的,我们开发者无法修改
		绑定语法:
			1.使用@符号可以绑定
			2.onclick或者addEventListener('click')
			3.在组件标签上使用@并配合.native修饰符,来给组件的根节点绑定原生事件
			
		触发:
			由于事件是W3C推出,浏览器负责实现的,所以事件的触发由浏览器负责
		
	自定义事件
		自定义事件是由Vue退出的一套事件机制
		一个组件具有哪些自定义事件,都是开发者可以随意取名的
		绑定语法:
			1.使用@符号可以绑定
			2.可以通过this.$on语法绑定
		触发:
			由于事件是Vue推出的,事件名是开发者自己自定义的,所以事件的触发由开发者自己触发
				语法:this.$emit(事件名称,数据)
		
	无论是原生事件还是自定义事件,在Vue中,都可以使用@绑定事件
	
问题:如何区分一个事件是原生事件,还是自定义事件?
回答:
	如果一个事件绑定在原生html标签上,那么这个事件就是原生事件
	如果一个事件绑定在组件标签上,那么这个事件就是自定义事件
	
	
进阶:
	1.v-model指令
		适用场景:需要同时实现父向子传参,以及子向父传参的场景
			由于它具有很强的被替代性,所以在前台项目中使用频率极低
			但是在后台项目中,会使用大量的UI组件,那么就需要使用v-model与他们打配合
		
		它具有两种使用方式
			1.对input框使用
				原理:
					1.将data中某个数据的值,作为input框的默认值进行展示
						<input type="text" :value="msg">
						
					2.当用户修改输入框时,Vue会自动修改data中对应的状态数据
						拆解:
							1.如何知道用户有没有修改输入框?
								肯定和事件监听有关
								事件源:输入框
								事件名:input(Vue默认选择)
									input事件代表内容发生变化就会触发
									change事件代表失去焦点才会触发
							2.自动修改data中对应的状态数据
								获取到输入框最新结果,然后更新给data
								问题:如何获取到输入框的最新结果?
								回答:通过event.target.value可以获取到最新结果
								
			2.对组件标签使用(双向数据传递)
					1.将data中某个数据的值,作为组件标签的标签属性传递下去(默认标签属性名:value)
    					<Child1 :value="msg"></Child1>
    					
					2.父组件还会给子组件绑定自定义事件(默认事件名:input)
    					<Child1 :value="msg" @input="(data)=>msg=data"></Child1>
    					
    				使用流程:
    					1.父组件在子组件的标签上,添加v-model指令,并输入指令值
    						格式例如:<Child1 v-model="msg" />
    						
    					2.子组件可以在自己的配置对象中,添加props规则,用于接收v-model传下来的数据
    						属性名默认是value
    						到目前为止,流程1和流程2已经实现了父向子传参
    					
    					3.在子组件中,可以调用$emit,触发input事件,并传入数据,用于修改父组件中对应的数据
    						这一步实现了子向父传参
    						
    					
    		总结:v-model具有两个效果,不仅将数据传递给了子组件,还给子组件自动绑定了一个自定义事件input
    			目的是为了接收到子组件返回的数据
    					
    				扩展:
    					1.model属性可以实现对v-model指令.默认属性名和事件名的自定义效果
    					
    2.sync修饰符
    	1.将data中某个数据的值,作为组件标签的标签属性传递下去(属性名可以DIY)
    			<Child1 :value="msg"></Child1>
    					
		2.父组件还会给子组件绑定自定义事件(事件名是update:+属性名)
    			<Child1 :value="msg" @update:value="(data)=>msg=data"></Child1>
    			
    	扩展:
    		由于它的功能和v-model几乎相同,所以Vue3最终将.sync修饰符删除
    			但是留下来的v-model指令的核心其实是sync的
    
    3.全局事件总线
    	1.角色
    		订阅者
    			想要数据的人,就是订阅者
    		发布者
    			拥有数据的人,就是发布者
    			
    	2.操作
    		订阅
    		发布
    		解绑订阅
    		
    	3.约束
    		1.订阅者和发布者必须同时存在
    		2.订阅操作必须在发布之前
    		
    	4.流程:
    		1.在Vue的原型对象上,添加$bus属性,并在内部存放一个Vue的实例对象
				Vue.prototype.$bus = new Vue();
				
			2.订阅方组件,需要执行订阅操作
    			this.$bus.$on('sendMsg',(value)=>{
      				console.log('sendMsg',value)
    			})
    			
    		3.发布方组件,需要执行发布操作
    			this.$bus.$emit('sendMsg',123)
    			
    		过程中遇到的问题:
    			1.属性名可以不用是$bus,可以随意取名
    			2.$bus中必须存放的是Vue的实例对象
    				否则后续使用$on或者$emit的时候会报错
    					error:this.$bus.$on is not a function
    		
    		
```

## 4.找到对应组件实例对象(频率低)

```
1.$parent
	数据类型:Vue Instance
	通过当前组件实例身上的$parent,可以快速获取到父组件的组件实例对象(也就是父组件的this)
	可以通过$parent属性,快速获取到父组件中的某些数据
	
2.$root
	数据类型:Vue Instance
	通过当前组件实例对象身上的$root属性,可以快速找到当前项目的根组件实例对象
		就是main.js中,new Vue得到的实例对象
		
3.$children
	数据类型:Array<Vue Instance>
	可以获取到当前组件的子组件实例对象组成的数组
	
	注意:不要修改该数组,因为该数组不是响应式的,修改他们内部实例对象的排列顺序,不会影响到页面的展示
	
4.$refs
	他必须配合ref标签属性使用
	只要被ref标记过的标签,在$refs对象中,都可以快速找到,而且ref标签属性的值,会成为$refs的属性名
		
	如果ref标记的是一个原生标签,那么$refs中存储的就是该标签的真实DOM
	如果ref标记的是一个组件标签,那么$refs中存储的就是该标签的组件实例对象
```

## 5.attrs和listeners(频率低)

```
$attrs
	数据类型:对象
	内部会存储props没有接收的标签属性
	他会将标签属性的名称作为对象的属性名,标签属性的值作为属性值进行存放
	
	扩展:
		v-bind指令,不仅可以在后面书写某个标签属性名
		v-bind指令可以不写属性名,直接接收一整个普通对象
			他会自动将该对象进行解构操作,对象的属性名会自动变为标签属性名,属性值会自动变为标签属性值进行展开
			
		在v-bind="$attrs"写法下,可以快速将当前组件不用的数据,传递给后代组件
			写法的优点:我们不再需要关注一共得到的多少个数据,我们只需要关心当前组件需要用几个
	
$listeners
	数据类型:对象
	内部会存储当前组件的所有的自定义事件
	他会将自定义事件的名称作为对象的属性名,自定义事件的回调函数作为属性值进行存放
	
	扩展:
		1.v-on指令,可以接收一个对象
			对象内部的属性名会自动成为事件名称,对象的属性值会成为事件的回调函数
			
		2.v-on指令会自动识别当前是在什么标签上使用
			如果v-on在原生标签上使用,绑定的一定是原生事件
			如果v-on在组件标签上使用,绑定的一定是自定义事件
				除了.native修饰符以外
```

## 6.插槽

```
他是所有通讯方式中,最特殊的一个
	因为其他的通讯方式都是用于传递某些数据,只有插槽是用来传递页面结构的

一共分为三种插槽
	1.默认插槽
		1.父组件在子组件的成对标签中,传入一段页面结构
			父组件不会显示这段结构,因为这段结构是传给子组件使用的
			
		2.子组件在自己的template中,使用slot组件来显示父组件传递下来的结构
		
	2.具名插槽
		1.父组件在子组件的成对标签中,传入一段页面结构
			注意:需要使用v-slot指令,来给当前的插槽取一个别名
			
		2.子组件在自己的template中,使用slot组件来显示父组件传递下来的结构
			注意:必须给slot组件添加标签属性name,用于声明显示的是哪一个插槽
			
		扩展:
			1.其实默认插槽也具有名称,名字叫做default
				在Vue2中,如果是要显示默认插槽,可以不写name="default"
				
	3.作用域插槽
		1.父组件在子组件的成对标签中,传入一段页面结构
			注意:需要使用v-slot指令,来给当前的插槽取一个别名
			
		2.子组件在自己的template中,使用slot组件来显示父组件传递下来的结构
			注意:必须给slot组件添加标签属性name,用于声明显示的是哪一个插槽
			
		3.子组件可以将自己的数据,通过标签属性形式,传给slot组件
			slot组件会将接收到的所有的标签属性,生成一个类似于props的对象,传给指定的插槽
		
		4.在插槽的v-slot指令之后,书写="变量名",用于接收传递过来的数据(就是流程3中生成的对象)
		
		5.在插槽结构中,使用接收到的数据即可
		
		注意:
			1.作用域插槽具有父向子传参的效果,只不过传递的是一段结构
			2.作用域插槽不存在子向父传参,
				由于App组件内部嵌套Child组件,而App组件把插槽结果传给了Child组件
				Child组件中,使用了slot组件显示这段插槽
					所以说明,嵌套关系为:App->Child->slot->结构
				传递数据的时候,是Child将自己的数据,以标签属性的形式传给了slot组件
					最终slot组件再将数据传给结构
				
```

## 7.VueRouter中的路由传参

## 8.Vuex