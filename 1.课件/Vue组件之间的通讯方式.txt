1.props
	适用场景:父子之间

	父向子:
		1.父组件在子组件的标签上,添加标签属性,将需要传递的数据作为属性值向下传递

		2.子组件在自己的配置对象中,添加props配置选项,用于声明想要接收哪些标签属性

		父给子的是数据本身

	子向父:
		1.父组件在子组件的标签上,添加标签属性,将需要接收的数据的函数作为属性值向下传递
			注意:函数必须声明在父组件的methods中才可以
				原因是,因为methods中,所有的方法的this都会被bind强行修改为父组件的实例对象

		2.子组件在自己的配置对象中,添加props配置选项,用于声明想要接收哪些标签属性

		3.子组件调用接收到的函数,并向内部传入参数

		4.最终传入的数据会触发父组件methods中的函数,实现子向父传输数据的过程

		父给子的是接收数据的函数
				

2.provide/inject
	适用场景:祖孙组件

	1.祖先组件,在自己的配置对象中,添加provide属性,并将需要暴露的数据放入该对象中
		注意:如果想要把data中的数据暴露出去,provide必须写成函数形式

	2.后代组件,在自己的配置对象中,添加inejct属性,并在数组中声明需要接收的属性即可

	注意:provide暴露的数据是非响应式的
		如果想要将数据变成响应式的,可以将数据先放入data中处理,然后在用provide暴露出去


3.自定义事件

	问题:请问什么是原生事件?什么是自定义事件
		原生事件->其实指的就是浏览器的标准事件机制
				他的标准是W3C推出的,例如input标签具有哪些事件这件事情是W3C制定的

		自定义事件->其实自定义事件是Vue推出的一套事件机制
				他的事件名是由开发者指定的,可以使用@符或者$on都可以绑定自定义事件,使用$emit可以触发自定义事件

		如何区分原生事件和自定义事件?
			如果是在原生DOM标签上,绑定的事件,那么这个事件一定是原生事件
			如果是在组件标签上,绑定的事件,那么这个事件就是自定义事件
				如果在绑定自定义事件的时候,加上了修饰符.native,那么这个事件就会变成原生事件,并绑定给当前组件的根DOM节点使用

	$on->该方法可以给指定的组件实例绑定自定义事件,并添加事件处理器
	$once->该方法也可以给指定的组件实例绑定自定义事件,并添加事件处理器,
			但是该事件只能触发一次,触发之后会自动解绑
	$emit->该方法可以触发某个组件实例身上的某类自定义事件
	$off->该方法可以解绑自定义事件
		如果不传入任何参数->解绑当前组件实例身上所有的事件
		如果只传入一个参数->解绑当前组件实例身上指定的事件的所有事件处理器
		如果传入两个参数->解绑当前组件实例身上指定的事件的指定事件处理器

	v-model
		对input框使用
			1.将data中的状态数据,作为input框的默认值进行展示(属性名是value)
    				<input type="text" :value="msg">

			2.当用户在input框中输入数据的时候,会自动修改data中对应的状态数据
    				<input type="text" :value="msg" @input="(event)=>msg=event.target.value">

		对组件使用			
			1.将data中的状态数据,作为组件的标签属性传递给子组件(默认属性名是value)
    				<HelloWorld :value="msg"/>

			2.给子组件绑定自定义事件,用来让子组件向父组件传递数据,修改对应的状态数据(默认事件名是input)
    				<HelloWorld :value="msg" @input="(data)=>msg=data"/>
			
			注意:可以通过model配置选项,自定义父组件使用v-model传下来的属性名和事件名

	.sync修饰符			
		1.将data中的状态数据,作为组件的标签属性传递给子组件(属性名可以自定义)


		2.给子组件绑定自定义事件,用来让子组件向父组件传递数据,修改对应的状态数据(事件名是update:属性名)
    			 <HelloWorld msg="Welcome to Your Vue.js App" :aaa="aaa" @update:aaa="(data)=>aaa=data"/>

	注意:在Vue3中,由于sync修饰符和v-model的功能过于相似,所以最终在Vue3中进行了二合一操作,语法还是使用v-model的语法,但是实际原理用的是sync的原理

	全局事件总线
		角色
			订阅者->想要接收数据的人就是订阅方
			发布者->想要发送数据的人就是发布方

		操作
			订阅
			发布
			解绑

		约束
			1.订阅者和发布者必须同时存在
			2.订阅操作必须在发布之前

		流程:
			1.创建全局事件总线对象,并将它放在Vue的原型对象上
				Vue.prototype.$bus = new Vue();

				注意:
					名称不一定非要是$bus,可以随便写
					$bus中必须放置一个Vue的实例对象,否则后面使用$on和$emit会报错

			2.在订阅方代码中,使用$on订阅消息,准备接收数据
   				 this.$bus.$on('abc',(data)=>{
      					console.log('abc',data)
    				})

			3.在发布方代码中,使用$emit发布数据,触发对应的全局事件
   			 	this.$bus.$emit('abc',666)
		

4.找到对应组件的实例对象
	$parent->可以获取到父组件的组件实例对象
	$root->可以获取到当前组件树的根组件实例对象
	$children->可以获取到子组件实例对象组成的数组
		注意:
			1.如果没有异步组件存在的情况下,该数组的排列顺序,与子组件挂载顺序相同

			2.不要操作这个数组内部的排列顺序,他对页面没有任何影响

	$refs->可以获取到组件template中标签组成的内容
		该属性必须和标签属性ref配合
		ref对原生标签使用
			可以获取到当前标签的原生DOM节点
		ref对组件标签使用
			可以获取到组件标签的组件实例对象

5.$attrs和$listeners
	$attrs->他会收集父组件传下来的,没有被props接收的标签属性
		数据类型:对象
			会将props不要的标签属性进行收集,标签属性名会成为$attrs的属性名,标签属性值会成为$attrs的属性值

		扩展:v-bind使用方法
			将一个对象传给v-bind指令,v-bind指令会自动将该对象进行解构处理,该对象的属性名会成为标签属性名,该对象的属性值会成为对象的属性值

	$listeners->他会收集当前组件实例身上所有的自定义事件
		数据类型:对象
			会将当前组件实例的自定义事件名称,作为$listeners对象的属性名,事件回调函数作为属性值进行存放

		扩展:v-on使用方法
			将一个对象传给v-on指令,v-on指令会自动将该对象的属性名作为事件名称,属性值作为事件的回调函数进行绑定

6.插槽
	一共分为三种
	相比于前面5种通讯方式,插槽特殊在父组件是传递结构给子组件显示

	插槽的适用场景:在封装子组件的时候,有部分页面结构无法确定,可能每次都不同,那么就是用插槽实现

	1.默认插槽
		1.父组件在子组件的成对标签中,写入一段结构,那么就可以将这结构传递给子组件使用
		2.子组件在自己的template标签中,使用slot组件,告知Vue,这段结构需要显示在哪里

	2.具名插槽
		1.父组件在子组件的成对标签中,写入一段结构,那么就可以将这结构传递给子组件使用
			在传递结构的时候,可以使用v-slot:名称指令,给当前结构取一个别名

		2.子组件在自己的template标签中,使用slot组件,告知Vue,这段结构需要显示在哪里
			可以在slot组件身上,添加标签属性name="名称",即可显示对应的具名插槽

			默认插槽个人认为也属于具名插槽的一员,因为如果没有给插槽取名,默认名称为default	

	3.作用域插槽		
		1.父组件在子组件的成对标签中,写入一段结构,那么就可以将这结构传递给子组件使用
			在传递结构的时候,可以使用v-slot:名称指令,给当前结构取一个别名

		2.子组件在自己的template标签中,使用slot组件,告知Vue,这段结构需要显示在哪里
			可以在slot组件身上,添加标签属性name="名称",即可显示对应的具名插槽

		3.在slot组件身上,添加标签属性,将需要在插槽中展示的数据,传入slot组件

		4.在父组件插槽结构的指令后面,可以创建一个变量,用于接收子组件传递的数据,
			该变量存储的是一个对象,这个对象的属性名来源于slot组件的标签属性名,属性值来源于标签属性值

		5.最终,可以在插槽结构中,使用插值语法展示传递过来的数据


	总结:所有的插槽都是父传子,没有子传父

7.VueRouter中的路由传参

8.Vuex
		

































